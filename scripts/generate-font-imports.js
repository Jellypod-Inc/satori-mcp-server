const fs = require('fs');
const path = require('path');
const fontkit = require('fontkit');

const fontsDir = path.join(__dirname, '../src/fonts');
const outputFile = path.join(__dirname, '../src/fonts/font-data.ts');

async function scanFontsDirectory(dir, basePath = '') {
  const fonts = [];
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    const relativePath = path.join(basePath, entry.name);
    
    if (entry.isDirectory()) {
      fonts.push(...await scanFontsDirectory(fullPath, relativePath));
    } else if (/\.(ttf|otf|woff)$/i.test(entry.name)) {
      const safeName = relativePath.replace(/[^a-zA-Z0-9]/g, '_').replace(/^_+|_+$/g, '');
      
      // Read font metadata
      try {
        const font = await fontkit.open(fullPath);
        
        // Get font family from metadata
        const fontFamily = font.familyName || 'Unknown';
        
        // Check if it's a variable font
        const isVariable = !!font.variationAxes;
        let weights = [];
        let hasItalic = false;
        
        if (isVariable && font.variationAxes.wght) {
          // Variable font - get weight range
          const weightAxis = font.variationAxes.wght;
          weights = {
            min: weightAxis.min,
            max: weightAxis.max,
            default: weightAxis.default
          };
        } else {
          // Static font - get single weight
          weights = font['OS/2']?.usWeightClass || 400;
        }
        
        // Check if font is italic
        hasItalic = font.italicAngle !== 0 || font['OS/2']?.fsSelection?.italic;
        
        fonts.push({
          importName: safeName,
          importPath: `./${relativePath.replace(/\\/g, '/')}`,
          fontFamily,
          fileName: entry.name,
          isVariable,
          weights,
          hasItalic
        });
      } catch (error) {
        console.warn(`Failed to parse font ${fullPath}:`, error);
        // Fallback if we can't parse the font
        fonts.push({
          importName: safeName,
          importPath: `./${relativePath.replace(/\\/g, '/')}`,
          fontFamily: basePath || 'Unknown',
          fileName: entry.name,
          isVariable: false,
          weights: 400,
          hasItalic: false
        });
      }
    }
  }
  
  return fonts;
}

// Generate the TypeScript file
async function generateFontImports() {
  const fonts = await scanFontsDirectory(fontsDir);

  let content = `// This file is auto-generated by scripts/generate-font-imports.js
// DO NOT EDIT MANUALLY

`;

  // Add imports
  fonts.forEach(font => {
    content += `// @ts-ignore\n`;
    content += `import ${font.importName} from "${font.importPath}";\n`;
  });

  content += `
export interface FontImport {
  name: string;
  family: string;
  data: string;
  fileName: string;
  isVariable: boolean;
  weights: number | { min: number; max: number; default: number };
  hasItalic: boolean;
}

export const fontImports: FontImport[] = [
`;

  // Add font data array
  fonts.forEach(font => {
    const weightsStr = typeof font.weights === 'object' 
      ? `{ min: ${font.weights.min}, max: ${font.weights.max}, default: ${font.weights.default} }`
      : font.weights;
    
    content += `  {
    name: "${font.importName}",
    family: "${font.fontFamily}",
    data: typeof ${font.importName} === 'string' ? ${font.importName}.split(',')[1] || ${font.importName} : ${font.importName},
    fileName: "${font.fileName}",
    isVariable: ${font.isVariable},
    weights: ${weightsStr},
    hasItalic: ${font.hasItalic}
  },\n`;
  });

  content += `];
`;

  fs.writeFileSync(outputFile, content);
  console.log(`Generated font imports for ${fonts.length} fonts`);
  fonts.forEach(font => {
    if (font.isVariable) {
      console.log(`  - ${font.fontFamily}/${font.fileName} (variable: ${font.weights.min}-${font.weights.max}, italic: ${font.hasItalic})`);
    } else {
      console.log(`  - ${font.fontFamily}/${font.fileName} (weight: ${font.weights}, italic: ${font.hasItalic})`);
    }
  });
}

generateFontImports().catch(console.error);